$Request = '2022-12-13 22:33:07: http://127.0.0.1:3999/functions/config/set?{"Algorithm"%3A%5B%5D%2C"APILogfile"%3A"Debug%5C%5CAPILog.txt"%2C"APIPort"%3A3999%2C"AutoReboot"%3Atrue%2C"AutoUpdate"%3Atrue%2C"AutoUpdateCheckInterval"%3A1%2C"BackupOnAutoUpdate"%3Atrue%2C"BadShareRatioThreshold"%3A0.05%2C"BalancesKeepAlive"%3Atrue%2C"BalancesShowAverages"%3Afalse%2C"BalancesShowInAllCurrencies"%3Afalse%2C"BalancesShowInMainCurrency"%3Atrue%2C"BalancesShowSums"%3Afalse%2C"BalancesTrackerExcludePool"%3A%5B"_BlockMasters"%5D%2C"BalancesTrackerLog"%3Afalse%2C"BalancesTrackerPollInterval"%3A10%2C"CalculatePowerCost"%3Atrue%2C"ConfigFileVersion"%3A"4.3.4.6"%2C"CPUMinerProcessPriority"%3A-2%2C"Currency"%3A"CHF"%2C"DecimalsMax"%3A6%2C"Delay"%3A0%2C"DisableDualAlgoMining"%3Afalse%2C"DisableMinerFee"%3Afalse%2C"DisableMinersWithFee"%3Afalse%2C"DisableSingleAlgoMining"%3Afalse%2C"Donation"%3A2%2C"EarningsAdjustmentFactor"%3A0.8%2C"ExcludeDeviceName"%3A%5B"CPU%2300"%5D%2C"ExcludeMinerName"%3A%5B%5D%2C"ExtraCurrencies"%3A%5B"ETH"%2C"USD"%2C"EUR"%2C"NZD"%2C"AUD"%2C"THB"%5D%2C"GPUMinerProcessPriority"%3A-1%2C"IdleDetection"%3Afalse%2C"IdleSec"%3A5%2C"IgnoreMinerFee"%3Afalse%2C"IgnorePoolFee"%3Afalse%2C"IgnorePowerCost"%3Atrue%2C"Interval"%3A30%2C"LogBalanceAPIResponse"%3Afalse%2C"LogToFile"%3A%5B"Info"%2C"Warn"%2C"Error"%2C"Verbose"%2C"Debug"%5D%2C"LogToScreen"%3A%5B"Info"%2C"Warn"%2C"Error"%2C"Verbose"%2C"Debug"%5D%2C"MinAccuracy"%3A0.5%2C"MinDataSample"%3A20%2C"MinDataSampleAlgoMultiplier"%3A{"X16r"%3A3}%2C"MinerInstancePerDeviceModel"%3Atrue%2C"MinerSet"%3A2%2C"MinerSwitchingThreshold"%3A2.5%2C"MinerWindowStyle"%3A"minimized"%2C"MinerWindowStyleNormalWhenBenchmarking"%3Atrue%2C"MiningDutchAPIKey"%3A"7c5ea2d2e997f5094a55969d3a855c4169b46d5eee6065d4fa9251e026980714"%2C"MiningDutchUserName"%3A"UselessGuru"%2C"MiningPoolHubAPIKey"%3A"28328accdd4306c631a881bd8130f0d258a94b0e33569e0eef7e83773d018c98"%2C"MiningPoolHubUserName"%3A"UselessGuru"%2C"MinInterval"%3A3%2C"MinWorker"%3A0%2C"MonitoringServer"%3A"https%3A%2F%2FUG-Miner.com"%2C"MonitoringUser"%3A"8e92d491-a5e6-42d7-8928-5be72d743b0c"%2C"NiceHashAPIKey"%3A"0dfa9c5b-12f9-4f62-9152-41d6a517de00"%2C"NiceHashAPISecret"%3A"15a4618a-1f3a-4b96-924a-48845f435d98f4f28ac4-a51b-4de0-bf8d-584929764dd5"%2C"NiceHashOrganizationId"%3A"f48afaf4-fc54-4645-af2d-56334a48aebb"%2C"NiceHashWallet"%3A"33hZYX8iFg5zm9E3geqrNgeP6TMzszZk5R"%2C"NiceHashWalletIsInternal"%3Atrue%2C"OpenFirewallPorts"%3Atrue%2C"PayoutCurrency"%3A"BTC"%2C"PoolAPIAllowedFailureCount"%3A3%2C"PoolAPIRetryInterval"%3A3%2C"PoolAPITimeout"%3A3%2C"PoolName"%3A%5B"Hiveon"%2C"MiningDutchPlus"%2C"MiningPoolHubCoins"%2C"NiceHash"%2C"ProHashingPlus"%2C"ZergPoolCoinsPlus"%2C"ZPoolPlus"%5D%2C"PoolsConfigFile"%3A".%5C%5CConfig%5C%5CPoolsConfig.json"%2C"PoolTimeout"%3A30%2C"PowerPricekWh"%3A{"00%3A00"%3A0.26}%2C"PowerUsage"%3A{"_GPU%2302"%3A35}%2C"PowerUsageIdleSystemW"%3A160%2C"ProfitabilityThreshold"%3A-12.6%2C"ProHashingAPIKey"%3A"8ea6a00dea6945172167708c9784b8deead1da2f5e543ef312bfc7ed1073fe4a"%2C"ProHashingMiningMode"%3A"PPLNS"%2C"ProHashingUserName"%3A"UselessGuru"%2C"Proxy"%3A""%2C"Region"%3A"Europe"%2C"ReportToServer"%3Atrue%2C"ShowAccuracy"%3Atrue%2C"ShowAllMiners"%3Afalse%2C"ShowChangeLog"%3Atrue%2C"ShowCoinName"%3Atrue%2C"ShowCurrency"%3Atrue%2C"ShowEarning"%3Atrue%2C"ShowEarningBias"%3Atrue%2C"ShowMinerFee"%3Atrue%2C"ShowPool"%3Atrue%2C"ShowPoolBalances"%3Afalse%2C"ShowPoolFee"%3Atrue%2C"ShowPowerCost"%3Atrue%2C"ShowPowerUsage"%3Atrue%2C"ShowProfit"%3Atrue%2C"ShowProfitBias"%3Atrue%2C"ShowUser"%3Afalse%2C"ShowWorkerStatus"%3Atrue%2C"LogViewerConfig"%3A".%5C%5CUtils%5C%5CUG-Miner_LogReader.xml"%2C"SnakeTailExe"%3A".%5C%5CUtils%5C%5CSnakeTail.exe"%2C"SSL"%3A"Prefer"%2C"StartGUI"%3Afalse%2C"StartGUIMinimized"%3Afalse%2C"StartupMode"%3A"Running"%2C"SubtractBadShares"%3Atrue%2C"SyncWindow"%3A3%2C"Transcript"%3Afalse%2C"UIStyle"%3A"light"%2C"UnrealMinerEarningFactor"%3A1%2C"UnrealPoolPriceFactor"%3A2%2C"UseAnycast"%3Atrue%2C"UseColorForMinerStatus"%3Atrue%2C"UsemBTC"%3Atrue%2C"UseMinerTweaks"%3Atrue%2C"Wallets"%3A{"BTC"%3A"1GPSq8txFnyrYdXL8t6S94mYdF8cGqVQJF"%2C"ETC"%3A"0x7CF99ec9029A98AFd385f106A93977D8105Fec0f"%2C"ETH"%3A"0x92e6F22C1493289e6AD2768E1F502Fc5b414a287"}%2C"Watchdog"%3Atrue%2C"WatchdogCount"%3A3%2C"WebGUI"%3Atrue%2C"WorkerName"%3A"Blackbox"}'


Set-Location("c:\Users\Stephan\Desktop\UG-Miner\")
$ScriptBody = "using module .\Includes\Include.psm1"; $Script = [ScriptBlock]::Create($ScriptBody); . $Script

$Parameters = @{ }
$Variables = [Ordered]@{ }
# $Variables.Miners = Get-Content .\Debug\Miners.json | ConvertFrom-Json
$Variables.Pools = Get-Content .\Debug\Pools.json | ConvertFrom-Json
$Variables.ConfigFile = ".\Config\config.json"
$Variables.PoolsConfigFile = ".\Config\PoolsConfig.json"
$Variables.Earnings = Get-Content .\Debug\Earnings.json | ConvertFrom-Json
$Variables.AvailableCommandLineParameters = @("Algorithm")
$Variables.WatchdogTimers = Get-Content .\Debug\WatchdogTimers.json | ConvertFrom-Json
$Variables.BalancesData = Get-Content "C:\Users\Stephan\Desktop\UG-Miner\Logs\BalancesTrackerData.json" | ConvertFrom-Json

# Load stats, required for stat management
Get-Stat | Out-Null

Read-Config -ConfigFile $Variables.ConfigFile

$Request = $Request.Substring(42)
$Path = $Request -replace '\?.+'

$Request -replace '.+\?' -split '&' | Foreach-Object { 
    $Key, $Value = $_ -split '='
    # Decode any url escaped characters in the key and value
    $Key = [URI]::UnescapeDataString($Key)
    $Value = [URI]::UnescapeDataString($Value)
    If ($Key -and $Value) { $Parameters.$Key = $Value }
}

# Create a new response and the defaults for associated settings
$Response = $Context.Response
$ContentType = "application/json"
$StatusCode = 200
$Data = ""

# Set the proper content type, status code and data for each resource
Switch ($Path) { 
    "/functions/algorithm/disable" { 
        # Disable algorithm@pool in poolsconfig.json
        $PoolNames = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Name
        $Algorithms = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Algorithm
        If ($Pools = @($Variables.Pools.Where({ $_.Name -in $PoolNames -and $_.Algorithm -in $Algorithms }))) { 
            $PoolsConfig = Get-Content -Path $Config.PoolsConfigFile | ConvertFrom-Json
            ForEach ($Pool in $Pools) { 
                If ($PoolsConfig.($Pool.Name).Algorithm -like "-*") { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm += "-$($Pool.Algorithm)" | Sort-Object -Unique)
                    $Pool.Reasons = [System.Collections.Generic.List[String]]@($Pool.Reasons.Add("Algorithm disabled (`-$($Pool.Algorithm)` in $($Pool.Name) pool config)") | Sort-Object -Unique)
                }
                Else { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm.Where({ $_ -ne "+$($Pool.Algorithm)" }) | Sort-Object -Unique)
                    $Pool.Reasons = [System.Collections.Generic.List[String]]@($Pool.Reasons.Add("Algorithm not enabled in $($Pool.Name) pool config") | Sort-Object -Unique)
                }
                $Pool.Available = $false
                $Data += "$($Pool.Algorithm)@$($Pool.Name)"
            }
            Remove-Variable Pool
            $Message = "$($Pools.Count) $(If ($Pools.Count -eq 1) { "pool" } Else { "pools" }) disabled."
            Write-Message -Level Verbose "Web GUI: $Message"
            $Data = "$($Data -join "`n")`n`n$Message"
            $PoolsConfig | Get-SortedObject | ConvertTo-Json -Depth 10 | Out-File -LiteralPath $Variables.PoolsConfigFile -Force
        }
        Else { 
            $Data = "No matching stats found."
        }
        Break
    }
    "/functions/algorithm/enable" { 
        # Enable algorithm@pool in poolsconfig.json
        $PoolNames = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Name
        $Algorithms = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Algorithm
        If ($Pools = @($Variables.Pools.Where({ $_.Name -in $PoolNames -and $_.Algorithm -in $Algorithms }))) { 
            $PoolsConfig = Get-Content -Path $Config.PoolsConfigFile | ConvertFrom-Json
            ForEach ($Pool in $Pools) { 
                If ($PoolsConfig.($Pool.Name).Algorithm -like "+*") { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm += "+$($Pool.Algorithm)" | Sort-Object -Unique)
                    $Pool.Reasons = [System.Collections.Generic.List[String]]@($Pool.Reasons.Where({ $_ -ne "Algorithm not enabled in $($Pool.Name) pool config" }) | Sort-Object -Unique)
                }
                Else { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm.Where({ $_ -ne "-$($Pool.Algorithm)" }) | Sort-Object -Unique)
                    $Pool.Reasons = [System.Collections.Generic.List[String]]@($Pool.Reasons.Where({ $_ -ne "Algorithm disabled (`-$($Pool.Algorithm)` in $($Pool.Name) pool config)" }) | Sort-Object -Unique)
                }
                If (-not $Pool.Reasons) { $Pool.Available = $true }
                $Data += "$($Pool.Algorithm)@$($Pool.Name)"
            }
            Remove-Variable Pool
            $Message = "$($Pools.Count) $(If ($Pools.Count -eq 1) { "pool" } Else { "pools" }) enabled."
            Write-Message -Level Verbose "Web GUI: $Message"
            $Data = "$($Data -join "`n")`n`n$Message"
            $PoolsConfig | Get-SortedObject | ConvertTo-Json -Depth 10 | Out-File -LiteralPath $Variables.PoolsConfigFile -Force
        }
        Else { 
            $Data = "No matching stats found."
        }
        Break
    }
    "/functions/api/stop" { 
        Write-Message -Level Verbose "API: API stopped!"
        Return
    }
    "/functions/balancedata/remove" { 
        If ($Parameters.Data) { 
            $BalanceDataEntries = $Variables.BalancesData
            $Variables.BalancesData = @((Compare-Object $Variables.BalancesData @($Parameters.Data | ConvertFrom-Json -ErrorAction Ignore) -PassThru -Property DateTime, Pool, Currency, Wallet).Where({ $_.SideIndicator -eq "<=" }) | Select-Object -ExcludeProperty SideIndicator)
            $Variables.BalancesData | ConvertTo-Json | Out-File ".\Data\BalancesTrackerData.json"
            $RemovedEntriesCount = $BalanceDataEntries.Count - $Variables.BalancesData.Count
            If ($RemovedEntriesCount-gt 0) { 
                $Message = "$RemovedEntriesCount $(If ($RemovedEntriesCount -eq 1) { "balance data entry" } Else { "balance data entries" }) removed."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = $Message
            }
            Else { 
                $Data = "No matching entries found."
            }
            Break
        }
    }
    "/functions/config/device/disable" { 
        ForEach ($Key in $Parameters.Keys) {
            If ($Values = @(($Parameters.$Key -split ',').Where({ $_ -notin $Config.ExcludeDeviceName }))) { 
                Try { 
                    $ExcludeDeviceName = $Config.ExcludeDeviceName
                    $Config.ExcludeDeviceName = @((@($Config.ExcludeDeviceName) + $Values) | Sort-Object -Unique)
                    Write-Config -ConfigFile $Variables.ConfigFile -Config $Config
                    $Data = "Device configuration changed`n`nOld values:"
                    $Data += "`nExcludeDeviceName: '[$($ExcludeDeviceName -join ', ')]'"
                    $Data += "`n`nNew values:"
                    $Data += "`nExcludeDeviceName: '[$($Config."ExcludeDeviceName" -join ', ')]'"
                    $Data += "`n`nConfiguration saved to '$($Variables.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`nIt will become active in next cycle."
                    ForEach ($DeviceName in $Values) { 
                        $Variables.Devices.Where({ $_.Name -eq $DeviceName }).ForEach(
                            { 
                                $_.State = [DeviceState]::Disabled
                                If ($_.SubStatus -in ("Benchmarking", "Running", "WarmingUp")) { $_.StatusInfo = "$($_.StatusInfo); will get disabled at end of cycle" }
                                Else { 
                                    $_.StatusInfo = "Disabled (ExcludeDeviceName: '$($_.Name)')"
                                    $_.Status = "Idle"
                                }
                            }
                        )
                    }
                    Remove-Variable DeviceName
                    Write-Message -Level Verbose "Web GUI: Device$(If ($Values.Count -ne 1) { "s" }) '$($Values -join ', ')' disabled. Configuration file '$($Variables.ConfigFile)' updated."
                }
                Catch { 
                    $Data = "Error saving configuration file '$($Variables.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`n`n[ $($_) ]"
                }
            }
            Else { 
                $Data = "No configuration change."
            }
        }
        Remove-Variable Key
        Break
    }
    "/functions/config/device/enable" { 
        ForEach ($Key in $Parameters.Keys) {
            If ($Values = @(($Parameters.$Key -split ',').Where({ $_ -in $Config.ExcludeDeviceName }))) { 
                Try { 
                    $ExcludeDeviceName = $Config.ExcludeDeviceName
                    $Config.ExcludeDeviceName = @($Config.ExcludeDeviceName.Where({ $_ -notin $Values }) | Sort-Object -Unique)
                    Write-Config -ConfigFile $Variables.ConfigFile -Config $Config
                    $Variables.FreshConfig = $false
                    $Data = "Device configuration changed`n`nOld values:"
                    $Data += "`nExcludeDeviceName: '[$($ExcludeDeviceName -join ', ')]'"
                    $Data += "`n`nNew values:"
                    $Data += "`nExcludeDeviceName: '[$($Config."ExcludeDeviceName" -join ', ')]'"
                    $Data += "`n`nConfiguration saved to '$($Variables.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`nIt will become active in next cycle."
                    $Variables.Devices.Where({ $_.Name -in $Values }).ForEach(
                        { 
                            $_.State = [DeviceState]::Enabled
                            If ($_.StatusInfo -like "* {*@*}; will get disabled at end of cycle") { $_.StatusInfo = $_.StatusInfo -replace '; will get enabled at end of cycle' }
                            Else { $_.Status = $_.StatusInfo = $_.SubStatus = "Idle" }
                        }
                    )
                    Write-Message -Level Verbose "Web GUI: Device$(If ($Values.Count -ne 1) { "s" }) '$($Values -join ', ')' enabled. Configuration file '$($Variables.ConfigFile)' updated."
                }
                Catch { 
                    $Data = "Error saving configuration file '$($Variables.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`n`n[ $($_) ]."
                }
            }
            Else {
                $Data = "No configuration change."
            }
        }
        Remove-Variable Key
        Break
    }
    "/functions/config/set" { 
        Try { 
            $TempConfig = ($Key | ConvertFrom-Json -AsHashtable)
            Write-Config -ConfigFile $Variables.ConfigFile -Config $TempConfig
            $TempConfig.Keys.ForEach({ $Config.$_ = $TempConfig.$_ })
            Remove-Variable TempConfig

            $Variables.Devices.Where({ $_.State -ne [DeviceState]::Unsupported }).ForEach(
                { 
                    If ($_.Name -in $Config.ExcludeDeviceName) { 
                        $_.State = [DeviceState]::Disabled
                        If ($_.Status -like "Mining *}") { $_.Status = "$($_.Status); will get disabled at end of cycle" }
                    }
                    Else { 
                        $_.State = [DeviceState]::Enabled
                        If ($_.Status -like "*; will get disabled at end of cycle") { $_.Status = $_.Status -replace '; will get disabled at end of cycle' } 
                        If ($_.Status -like "Disabled *") { $_.Status = "Idle" }
                    }
                }
            )
            $Variables.RestartCycle = $true
            $Variables.FreshConfig = $false
            Write-Message -Level Verbose "Web GUI: Configuration saved. It will become fully active in the next cycle."
            $Data = "Configuration saved to '$($Variables.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`nIt will become fully active in the next cycle."
        }
        Catch { 
            $Data = "Error saving configuration file '$($Variables.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`n`n[ $($_) ]."
        }
        Break
    }
    "/functions/file/edit" {
        $Data = Edit-File $Parameters.FileName
        Break
    }
    "/functions/file/showcontent" {
        $Data = (Get-Content -Path $Parameters.FileName -Raw)
        $ContentType = "text/html"
        Break
    }
    "/functions/log/get" { 
        $Lines = If ([Int]$Parameters.Lines) { [Int]$Parameters.Lines } Else { 100 }
        $Data = "$((Get-Content -Path $Variables.LogFile -Tail $Lines).ForEach({ "$($_)`n" }))"
        Break
    }
    "/functions/mining/getstatus" { 
        If ($Variables.FreshConfig) { 
            $Data = "FreshConfig" | ConvertTo-Json
        }
        Else { 
            $Data = $Variables.NewMiningStatus | ConvertTo-Json
        }
        Break
    }
    "/functions/mining/pause" { 
        If ($Variables.MiningStatus -ne "Paused") { 
            $Variables.NewMiningStatus = "Paused"
            $Data = "Mining is being paused...`n$(If ($Variables.BalancesTrackerPollInterval -gt 0) { If ($Variables.BalancesTrackerRunning) { "Balances tracker running." } Else { "Balances tracker starting..." } })"
            $Variables.RestartCycle = $true
        }
        Break
    }
    "/functions/mining/start" { 
        If ($Variables.MiningStatus -ne "Running") { 
            $Variables.NewMiningStatus = "Running"
            $Data = "Mining processes starting...`n$(If ($Variables.BalancesTrackerPollInterval -gt 0) { If ($Variables.BalancesTrackerRunning) { "Balances tracker running." } Else { "Balances tracker starting..." } })"
            $Variables.RestartCycle = $true
        }
        Break
    }
    "/functions/mining/stop" { 
        If ($Variables.MiningStatus -ne "Idle") { 
            $Variables.NewMiningStatus = "Idle"
            $Data = "$($Variables.Branding.ProductLabel) is stopping...`n"
            $Variables.RestartCycle = $true
        }
        Break
    }
    "/functions/querypoolapi" { 
        If (-not $Config.PoolsConfig.$($Parameters.Pool).BrainConfig.$($Parameters.Type)) { 
            $Data = "No pool configuration data for '/functions/querypoolapi?Pool=$($Parameters.Pool)&Type=$($Parameters.Type)'."
        }
        ElseIf (-not ($Data = (Invoke-RestMethod -Uri $Config.PoolsConfig.$($Parameters.Pool).BrainConfig.$($Parameters.Type) -Headers @{ "Cache-Control" = "no-cache" } -SkipCertificateCheck -TimeoutSec 5) | ConvertTo-Json)) {
            $Data = "No data for '/functions/querypoolapi?Pool=$($Parameters.Pool)&Type=$($Parameters.Type)'."
        }
        break
    }
    "/functions/removeorphanedminerstats" { 
        If ($StatNames = Remove-ObsoleteMinerStats) { 
            $Data = $StatNames | ConvertTo-Json
        }
        Else { 
            $Data = "No matching stats found."
        }
        Break
    }
    "/functions/getminerdetail" { 
        $Miner = $Variables.Miners.Where({ $_.Info -eq $Key})
        If ($Miner) { 
            $Data = $Miner | ConvertTo-Json -Depth 10
        }
        Else { 
            $Data = "Miner with key '$Key' not found."
        }
        Break
    }
    "/functions/stat/disable" { 
        If ($Parameters.Miners) { 
            If ($Miners = @(Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Variables.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info)) { 
                $Data = @()
                $Miners.Where({ -not $_.Disabled }).ForEach(
                    { 
                        $Data += $_.Name
                        ForEach ($Worker in $_.Workers) { 
                            Disable-Stat -Name "$($_.Name)_$($Worker.Pool.Algorithm)_Hashrate"
                            $Worker.Hashrate = [Double]::NaN
                        }
                        Remove-Variable Worker
                        $_.Disabled = $true
                        $_.Reasons += "Disabled by user"
                        $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -ne "Disabled by user" }) | Sort-Object -Unique)
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "$($Data.Count) $(If ($Data.Count -eq 1) { "miner" } Else { "miners" }) disabled."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$($Data -join "`n")`n`n$Message"
            }
            Else { 
                $Data = "No matching miner stats found."
            }
            Break
        }
    }
    "/functions/stat/enable" { 
        If ($Parameters.Miners) { 
            If ($Miners = @(Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Variables.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info)) { 
                $Data = @()
                $Miners.Where({ $_.Disabled }).ForEach(
                    { 
                        $Data += $_.Name
                        ForEach ($Worker in $_.Workers) { 
                            Enable-Stat -Name "$($_.Name)_$($Worker.Pool.Algorithm)_Hashrate"
                        }
                        Remove-Variable Worker
                        $_.Disabled = $false
                        $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -ne "Disabled by user" }) | Sort-Object -Unique)
                        If (-not $_.Reasons) { $_.Available = $true }
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "$($Data.Count) $(If ($Data.Count -eq 1) { "miner" } Else { "miners" }) enabled."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$($Data -join "`n")`n`n$Message"
            }
            Else { 
                $Data = "No matching miner stats found."
            }
            Break
        }
    }
    "/functions/stat/get" { 
        $TempStats = @(If ($null -ne $Parameters.Value) { @($Stats.psBase.Keys.Where({ $_ -like "*_$($Parameters.Type)" -and $Stats[$_].Live -eq $Parameters.Value }).ForEach({ $Stats[$_] })) } Else { @($Stats) })
        If ($TempStats) { 
            If ($null -ne $Parameters.Value) { 
                ($TempStats.Name | Sort-Object).ForEach({ $Data += "$($_ -replace '(_Hashrate|_PowerConsumption)$')`n" })
                If ($Parameters.Type -eq "Hashrate") { $Data += "`n$($TempStats.Count) stat file$(If ($TempStats.Count -ne 1) { "s" }) with $($Parameters.Value)H/s hashrate." }
                ElseIf ($Parameters.Type -eq "PowerConsumption") { $Data += "`n$($TempStats.Count) stat file$(If ($TempStats.Count -ne 1) { "s" }) with $($Parameters.Value)W power consumption." }
            }
            Else { 
                $Data = $TempStats | ConvertTo-Json
            }
        }
        Else { 
            $Data = "No matching stats found."
        }
        Break
    }
    "/functions/stat/remove" { 
        If ($Parameters.Pools) { 
            If ($Pools = @(Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Variables.Pools | Select-Object) @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Algorithm, Currency, Name)) { 
                $Data = @()
                ($Pools | Sort-Object -Property Name, Algorithm, Currency).ForEach(
                    { 
                        $StatName = "$($_.Name)_$($_.Algorithm)$(If ($_.Currency) { "-$($_.Currency)" })"
                        $Data += $StatName
                        Remove-Stat -Name "$($StatName)_Profit"
                        $_.Reasons = [System.Collections.Generic.List[String]]@()
                        $_.Price = $_.Price_Bias = $_.StablePrice = $_.Accuracy = [Double]::Nan
                        $_.Available = $true
                        $_.Disabled = $false
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Reset pool stats for $($Pools.Count) $(If ($Pools.Count -eq 1) { "pool" } Else { "pools" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$($Data -join "`n")`n`n$Message"
            }
            Else { 
                $Data = "No matching pool stats found."
            }
            Break
        }
        ElseIf ($Parameters.Miners -and $Parameters.Type -eq "Hashrate") { 
            If ($Miners = @(Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Variables.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info)) { 
                $Data = @()
                $Miners.ForEach(
                    { 
                        $_.Activated = 0 # To allow 3 attempts
                        $_.Available = $true
                        $_.Benchmark = $true
                        $_.Earning_Accuracy = [Double]::NaN
                        $_.Disabled = $false
                        $Data += $_.Name
                        ForEach ($Worker in $_.Workers) { 
                            Remove-Stat -Name "$($_.Name)_$($Worker.Pool.Algorithm)_Hashrate"
                            $Worker.Hashrate = [Double]::NaN
                        }
                        Remove-Variable Worker
                        
                        # Clear power consumption
                        Remove-Stat -Name "$($_.Name)_PowerConsumption"
                        $_.PowerConsumption = $_.PowerCost = $_.Profit = $_.Profit_Bias = $_.Earning = $_.Earning_Bias = [Double]::NaN

                        # Remove watchdog
                        $Variables.WatchdogTimers = @($Variables.WatchdogTimers | Where-Object MinerName -ne $_.Name)

                        $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -ne "Disabled by user" }))
                        $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -ne "0 H/s Stat file" }))
                        $_.Reasons = [System.Collections.Generic.List[String]] @($_.Reasons.Where({ $_ -notlike "Unreal profit data *" }) | Sort-Object -Unique)
                        If (-not $_.Reasons) { $_.Available = $true }
                        If ($_.Status -eq "Disabled") { $_.Status = "Idle" }
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Re-benchmark triggered for $($Data.Count) $(If ($Data.Count -eq 1) { "miner" } Else { "miners" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$($Data -join "`n")`n`n$Message"
            }
            Else { 
                $Data = "No matching hashrate stats found."
            }
            Break
        }
        ElseIf ($Parameters.Miners -and $Parameters.Type -eq "PowerConsumption") { 
            If ($Miners = @(Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Variables.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info)) { 
                $Data = @()
                $Miners.ForEach(
                    { 
                        If ($_.Earning -eq 0) { $_.Available = $true }
                        If ($Variables.CalculatePowerCost) { 
                            $_.MeasurePowerConsumption = $true
                            $_.Activated = 0 # To allow 3 attempts
                        }
                        $_.PowerConsumption = [Double]::NaN
                        $StatName = $_.Name
                        $Data += $StatName
                        Remove-Stat -Name "$($StatName)_PowerConsumption"
                        $_.PowerConsumption = $_.PowerCost = $_.Profit = $_.Profit_Bias = $_.Earning = $_.Earning_Bias = [Double]::NaN
                        If ($_.Status -eq "Disabled") { $_.Status = "Idle" }
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Re-measure power consumption triggered for $($Data.Count) $(If ($Data.Count -eq 1) { "miner" } Else { "miners" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$($Data -join "`n")`n`n$Message"
            }
            Else { 
                $Data = "No matching power consumption stats found."
            }
            Break
        }
        If ($Parameters.Value) { $TempStats = @($Stats.psBase.Keys.Where({ $_ -like "*_$($Parameters.Type)" -and  $Stats[$_].Live -eq $Parameters.Value }).ForEach({ $Stats[$_] })) }
        Else { $TempStats = @( (Get-ChildItem -Path ".\Stats\*_$($Parameters.Type).txt").BaseName.ForEach({ $Stats[$_] })) }
        If ($TempStats) { 
            $Data = @()
            ($TempStats | Sort-Object -Property Name).ForEach(
                { 
                    Remove-Stat -Name $_.Name
                    $Data += $_.Name -replace '(_Hashrate|_PowerConsumption)$'
                }
            )
            $Data = $Data | Sort-Object -Unique
            If ($Parameters.Type -eq "Hashrate") { $Message = "Reset $($TempStats.Count) stat file$(If ($TempStats.Count -ne 1) { "s" })$(If ($null -ne $Parameters.Value) { " with $($Parameters.Value)H/s hashrate" })." }
            ElseIf ($Parameters.Type -eq "PowerConsumption") { $Message = "Reset $($TempStats.Count) stat file$(If ($TempStats.Count -ne 1) { "s" })$(If ($null -ne $Parameters.Value) { " with $($Parameters.Value)W power consumption" })." }
            ElseIf ($Parameters.Type -eq "Profit") { $Message = "Reset $($TempStats.Count) pool stat file$(If ($TempStats.Count -ne 1) { "s" })." }
            Write-Message -Level Info "Web GUI: $Message"
            $Data = "$($Data -join "`n")`n`n$Message"
        }
        Else { 
            $Data = "No matching stats found."
        }
        Break
    }
    "/functions/stat/set" { 
        If ($Parameters.Miners -and $Parameters.Type -eq "Hashrate" -and $null -ne $Parameters.Value) { 
            $Data = @()
            If ($Miners = @(Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Variables.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info)) {
                $Miners.ForEach(
                    { 
                        If ($Parameters.Value -le 0 -and $Parameters.Type -eq "Hashrate") { $_.Available = $false; $_.Disabled = $true }
                        $Data += $_.Name
                        ForEach ($Algorithm in $_.Algorithms) { 
                            $StatName = "$($_.Name)_$($Algorithm)_$($Parameters.Type)"
                            If ($Parameters.Value -eq 0) { # Miner failed
                                Remove-Stat -Name $StatName
                                Set-Stat -Name $StatName -Value $Parameters.Value -FaultDetection $false | Out-Null
                                $_.Profit = $_.Profit_Bias = $_.Earning = $_.Earning_Bias = $_.Earning_Accuracy = [Double]::NaN
                                $_.Available = $false
                                $_.Disabled = $false
                                If ($_.Reasons -notcontains "0 H/s Stat file" ) { $_.Reasons.Add("0 H/s Stat file") }
                                $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -notlike "Disabled by user" }) | Sort-Object -Unique)
                                $_.Status = [MinerStatus]::Failed
                            }
                        }
                        Remove-Variable Algorithm
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "$(If ($Data.Count -eq 1) { "The miner is" } Else { "$($Data.Count) miners are" }) $(If ($Parameters.Value -eq 0) { "marked as failed" } ElseIf ($Parameters.Value -eq -1) { "disabled" } Else { "set to value $($Parameters.Value)" })." 
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$($Data -join "`n")`n`n$Message" 
            }
            Else { 
                $Data = "No matching miners found."
            }
            Break
        }
    }
    "/functions/switchinglog/clear" { 
        Get-ChildItem -Path ".\Logs\switchinglog.csv" -File | Remove-Item -Force
        $Data = "Switching log '.\Logs\switchinglog.csv' cleared."
        Write-Message -Level Verbose "Web GUI: $Data"
        Break
    }
    "/functions/variables/get" { 
        If ($Key) { 
            $Data = $Variables.($Key -replace '\\|/', '.' -split '\.'[-1]) | Get-SortedObject | ConvertTo-Json -Depth 10
        }
        Else { 
            $Data = $Variables.psBase.Keys | Sort-Object | ConvertTo-Json -Depth 1
        }
        Break
    }
    "/functions/watchdogtimers/remove" { 
        $Data = @()
        ForEach ($Miner in @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore)) { 
            # Update miner
            $Variables.Miners.Where({ $_.Name -eq $Miner.Name -and $_.Reasons -like "Miner suspended by watchdog *" }).ForEach(
                { 
                    $Data += "$($_.Name)"
                    $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -notlike "Miner suspended by watchdog *" }) | Sort-Object -Unique)
                    If (-not $_.Reasons) { $_.Available = $true }
                }
            )

            # Remove Watchdog timers
            $Variables.WatchdogTimers = @($Variables.WatchdogTimers.Where({ $_.MinerName -ne $Miner.Name }))
        }
        Remove-Variable Miner

        ForEach ($Pool in @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore)) { 
            # Update pool
            $Variables.Pools.Where({ $_.Name -eq $Pool.Name -and $_.Algorithm -eq $Pool.Algorithm -and $_.Reasons -like "Pool suspended by watchdog *" }).ForEach(
                { 
                    $Data += "$($_.Key) ($($_.Region))"
                    $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -notlike "Pool suspended by watchdog *" }) | Sort-Object -Unique)
                    If (-not $_.Reasons) { $_.Available = $true }
                }
            )

            # Remove Watchdog timers
            $Variables.WatchdogTimers = @($Variables.WatchdogTimers.Where({ $_.PoolName -ne $Pool.Name -or $_.Algorithm -ne $Pool.Algorithm }))
        }
        Remove-Variable Pool
        If ($Data) { 
            $Data = $Data | Sort-Object -Unique
            $Message = "$($Data.Count) watchdog $(If ($Data.Count -eq 1) { "timer" } Else { "timers" }) removed."
            Write-Message -Level Verbose "Web GUI: $Message"
            $Data = "$($Data -join "`n")`n`n$Message"
        }
        Else { 
            $Data = "No matching watchdog timers found."
        }
        Break
    }
    "/functions/watchdogtimers/reset" { 
        $Variables.WatchDogTimers = @()
        $Variables.Miners.ForEach(
            { 
                $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -notlike "Miner suspended by watchdog *" }) | Sort-Object -Unique)
                $_.Where({ -not $_.Reasons }).ForEach({ $_.Available = $true })
            }
        )
        $Variables.Pools.ForEach(
            { 
                $_.Reasons = [System.Collections.Generic.List[String]]@($_.Reasons.Where({ $_ -notlike "*Pool suspended by watchdog" }) | Sort-Object -Unique)
                $_.Where({ -not $_.Reasons }).ForEach({ $_.Available = $true })
            }
        )
        Write-Message -Level Verbose "Web GUI: All watchdog timers reset."
        $Data = "Watchdog timers will be recreated in next cycle."
        Break
    }
    "/algorithms" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Algorithms | Select-Object)
        Break
    }
    "/algorithms/lastused" { 
        $Data = ConvertTo-Json -Depth 10 $Variables.AlgorithmsLastUsed
        Break
    }
    "/allcurrencies" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.AllCurrencies)
        break
    }
    "/apiversion" { 
        $Data = $APIVersion
        Break
    }
    "/balances" { 
        $Data = ConvertTo-Json -Depth 10 ($Variables.Balances | Sort-Object -Property DateTime -Bottom 10000 | Select-Object)
        Break
    }
    "/balancedata" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.BalancesData | Sort-Object -Property DateTime -Descending)
        Break
    }
    "/btc" { 
        $Data = $Variables.Rates.BTC.($Config.MainCurrency)
        Break
    }
    "/balancescurrencies" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.BalancesCurrencies)
        break
    }
    "/braindata" { 
        $Data = ConvertTo-Json -Depth 2 ($Variables.BrainData | Get-SortedObject)
        Break
    }
    "/coinnames" { 
        $Data = Get-Content -Path ".\Data\CoinNames.json"
        Break
    }
    "/config" {
        $Data = ConvertTo-Json -Depth 10 (Get-Content -Path $Variables.ConfigFile | ConvertFrom-Json -Depth 10 | Get-SortedObject)
        If (-not ($Data | ConvertFrom-Json).ConfigFileVersion) { 
            $Data = ConvertTo-Json -Depth 10 ($Config | Select-Object -ExcludeProperty PoolsConfig)
        }
        Break
    }
    "/configfile" { 
        $Data = $Variables.ConfigFile
        break
    }
    "/configrunning" {
        $Data = ConvertTo-Json -Depth 10 ($Config | Get-SortedObject)
        Break
    }
    "/currency" { 
        $Data = $Config.MainCurrency
        Break
    }
    "/currencyalgorithm" { 
        $Data = Get-Content -Path ".\Data\CurrencyAlgorithm.json"
        Break
    }
    "/dagdata" { 
        $Data = ConvertTo-Json -Depth 10 ($Variables.DAGdata | Select-Object)
        Break
    }
    "/devices" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Devices | Select-Object | Sort-Object -Property Name)
        Break
    }
    "/devices/enabled" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Devices.Where({ $_.State -eq "Enabled" }) | Sort-Object -Property Name)
        Break
    }
    "/devices/disabled" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Devices.Where({ $_.State -eq "Disabled" }) | Sort-Object -Property Name)
        Break
    }
    "/devices/unsupported" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Devices.Where({ $_.State -eq "Unsupported" }) | Sort-Object -Property Name)
        Break
    }
    "/donationdata" { 
        $Data = ConvertTo-Json $Variables.DonationData
        Break
    }
    "/donationlog" { 
        $Data = ConvertTo-Json $Variables.DonationLog
        Break
    }
    "/driverversion" { 
        $Data = ConvertTo-Json -Depth 10 ($Variables.DriverVersion | Select-Object)
        Break
    }
    "/earningschartdata" { 
        $Data = ConvertTo-Json $Variables.EarningsChartData
        Break
    }
    "/equihashcoinpers" { 
        $Data = Get-Content -Path ".\Data\EquihashCoinPers.json"
        Break
    }
    "/extracurrencies" { 
        $Data = ConvertTo-Json -Depth 10 $Config.ExtraCurrencies
        break
    }
    "/fiatcurrencies" { 
        $Data = ConvertTo-Json -Depth 10 ($Variables.FIATcurrencies | Select-Object)
        Break
    }
    "/miners" { 
        $Data = ConvertTo-Json -Depth 4 -Compress @(($Variables.Miners | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).ForEach({ If ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning | Sort-Object @{ Expression = { $_.Best }; Descending = $true }, DeviceNames, Name)
        Break
    }
    "/miners/available" { 
        $Bias = If ($Variables.CalculatePowerCost -and -not $Config.IgnorePowerCost) { "Profit_Bias" } Else { "Earning_Bias" }
        $Data = ConvertTo-Json -Depth 4 @($Variables.Miners.Where({ $_.Available }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object DeviceNames, @{ Expression = $Bias; Descending = $true })
        Remove-Variable Bias
        Break
    }
    "/miners/bestperdevice" { 
        $Data = ConvertTo-Json -Depth 4 @(($Variables.MinersBestPerDevice | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).ForEach({ If ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning | Sort-Object -Property DeviceName)
        Break
    }
    "/miners/best" { 
        $Data = ConvertTo-Json -Depth 4 @($Variables.MinersBest | Sort-Object DeviceNames | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, StatEnd, StatStart, SideIndicator, ValidDataSampleTimestamp)
        Break
    }
    "/miners/disabled" { 
        $Data = ConvertTo-Json -Depth 4 @($Variables.Miners.Where({ $_.Status -eq [MinerStatus]::Disabled }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object -Property { $_.DeviceNames }, EndTime)
        Break
    }
    "/miners/failed" { 
        $Data = ConvertTo-Json -Depth 4 @($Variables.Miners.Where({ $_.Status -eq [MinerStatus]::Failed }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object -Property { $_.DeviceNames }, EndTime)
        Break
    }
    "/miners/launched" { 
        $Data = ConvertTo-Json -Depth 4 @(($Variables.MinersBest | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).ForEach({ $_.Workers = $_.WorkersRunning; $_ }) | Select-Object -ExcludeProperty WorkersRunning)
        Break
    }
    "/miners/optimal" { 
        $Bias = If ($Variables.CalculatePowerCost -and -not $Config.IgnorePowerCost) { "Profit_Bias" } Else { "Earning_Bias" }
        $Data = ConvertTo-Json -Depth 4 @($Variables.MinersOptimal | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object @{ Expression = { $_.Best }; Descending = $true }, DeviceNames, @{ Expression = $Bias; Descending = $true })
        Remove-Variable Bias
        Break
    }
    "/miners/running" { 
        $Data = ConvertTo-Json -Depth 4 @(($Variables.Miners.Where({ $_.Status -eq [MinerStatus]::Running }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).ForEach({ $_.Workers = $_.WorkersRunning; $_ }) | Select-Object -ExcludeProperty WorkersRunning)
        Break
    }
    "/miners/unavailable" { 
        $Data = ConvertTo-Json -Depth 4 @($Variables.Miners.Where({ $_.Available -ne $true }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object -Property { $_.DeviceNames }, Name, Algorithm)
        Break
    }
    "/miningpowercost" { 
        $Data = $Variables.MiningPowerCost
        Break
    }
    "/miningearning" { 
        $Data = $Variables.MiningEarning
        Break
    }
    "/miningprofit" { 
        $Data = $Variables.MiningProfit
        Break
    }
    "/poolname" { 
        $Data = ConvertTo-Json -Depth 10 $Config.PoolName
        break
    }
    "/pooldata" { 
        $Data = ConvertTo-Json -Depth 10 $Variables.PoolData
        break
    }
    "/poolsconfig" { 
        $Data = ConvertTo-Json -Depth 10 ($Config.PoolsConfig | Select-Object)
        Break
    }
    "/poolsconfigfile" { 
        $Data = $Config.PoolsConfigFile
        Break
    }
    "/pools" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Pools | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/added" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.PoolsAdded | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/available" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Pools.Where({ $_.Available }) | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/best" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.PoolsBest | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/expired" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.PoolsExpired | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/new" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.PoolsNew | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/minersprimaryalgorithm" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.MinerPools[0] | Select-Object)
        Break
    }
    "/pools/minerssecondaryalgorithm" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.MinerPools[1] | Select-Object)
        Break
    }
    "/pools/lastearnings" { 
        $Data = ConvertTo-Json -Depth 10 $Variables.PoolsLastEarnings
        Break
    }
    "/pools/lastused" { 
        $Data = ConvertTo-Json -Depth 10 $Variables.PoolsLastUsed
        Break
    }
    "/pools/unavailable" { 
        $Data = ConvertTo-Json -Depth 10  @($Variables.Pools.Where({ -not $_.Available }) | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/pools/updated" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.PoolsUpdated | Select-Object | Sort-Object -Property Algorithm, Name, Region)
        Break
    }
    "/poolreasons" { 
        $Data = ConvertTo-Json -Depth 10 ($Variables.Pools.Where({ -not $_.Available }).Reasons | Sort-Object -Unique)
        Break
    }
    "/poolvariants" { 
        $Data = ConvertTo-Json -Depth 10 $Variables.PoolVariants
        break
    }
    "/rates" { 
        $Data = ConvertTo-Json -Depth 10 ($Variables.Rates | Select-Object)
        Break
    }
    "/refreshtimestamp" { 
        $Data = $Variables.RefreshTimestamp | ConvertTo-Json
        break
    }
    "/regions" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Regions[0] | Sort-Object)
        Break
    }
    "/regionsdata" { 
        $Data = ConvertTo-Json -Depth 10 $Variables.Regions
        Break
    }
    "/stats" { 
        $Data = ConvertTo-Json -Depth 10 ($Stats | Select-Object)
        Break
    }
    "/summarytext" { 
        $Data = ConvertTo-Json -Depth 10 @((($Variables.Summary -replace ' / ', '/' -replace '&ensp;', ' ' -replace '   ', '  ') -split '<br>').trim())
        Break
    }
    "/summary" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.Summary | Select-Object)
        Break
    }
    "/switchinglog" { 
        $Data = ConvertTo-Json -Depth 10 @(Get-Content ".\Logs\switchinglog.csv" | ConvertFrom-Csv | Select-Object -Last 1000 | Sort-Object -Property DateTime -Descending)
        Break
    }
    "/unprofitablealgorithms" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.UnprofitableAlgorithms | Select-Object)
        Break
    }
    "/version" { 
        $Data = ConvertTo-Json @("$($Variables.Branding.ProductLabel) Version: $($Variables.Branding.Version)", "API Version: $($Variables.APIVersion)", "PWSH Version: $($PSVersionTable.PSVersion.ToString())")
        Break
    }
    "/watchdogtimers" { 
        $Data = ConvertTo-Json -Depth 10 @($Variables.WatchdogTimers | Select-Object)
        Break
    }
    "/wallets" { 
        $Data = ConvertTo-Json -Depth 10 ($Config.Wallets | Select-Object)
        Break
    }
    "/watchdogexpiration" { 
        $Data = $Variables.WatchdogReset
        Break
    }
    "/workers" { 
        If ($Config.ShowWorkerStatus -and $Config.MonitoringUser -and $Config.MonitoringServer -and $Variables.WorkersLastUpdated -lt [DateTime]::Now.AddSeconds(-30)) { 
            Read-MonitoringData
        }
        $Workers = [System.Collections.ArrayList]@(
            $Variables.Workers | Select-Object @(
                @{ Name = "Algorithm"; Expression = { ($_.data.ForEach({ $_.Algorithm -split ',' -join ' & ' })) -join '<br>' } }, 
                @{ Name = "Benchmark Hashrate"; Expression = { ($_.data.ForEach({ ($_.EstimatedSpeed.ForEach({ If ([Double]$_ -gt 0) { "$($_ | ConvertTo-Hash)/s" -replace '\s+', ' ' } Else { "-" } })) -join ' & ' })) -join '<br>' } }, 
                @{ Name = "Currency"; Expression = { $_.Data.Currency | Select-Object -Unique } }, 
                @{ Name = "EstimatedEarning"; Expression = { [Decimal](($_.Data.Earning | Measure-Object -Sum | Select-Object -ExpandProperty Sum) * $Variables.Rates.BTC.($_.Data.Currency | Select-Object -Unique)) } }, 
                @{ Name = "EstimatedProfit"; Expression = { [Decimal]($_.Profit * $Variables.Rates.BTC.($_.Data.Currency | Select-Object -Unique)) } }, 
                @{ Name = "LastSeen"; Expression = { "$($_.date)" } }, 
                @{ Name = "Live Hashrate"; Expression = { ($_.data.ForEach({ ($_.CurrentSpeed.ForEach({ If ([Double]$_ -gt 0) { "$($_ | ConvertTo-Hash)/s" -replace '\s+', ' ' } Else { '-' } })) -join ' & ' })) -join '<br>' } }, 
                @{ Name = "Miner"; Expression = { $_.data.name -join '<br/>'} }, 
                @{ Name = "Pool"; Expression = { ($_.data.ForEach({ (($_.Pool -split ",").ForEach({ $_ -replace 'Internal$', ' (Internal)' -replace 'External', ' (External)' })) -join ' & '})) -join '<br>' } }, 
                @{ Name = "Status"; Expression = { $_.status } }, 
                @{ Name = "Version"; Expression = { $_.version } }, 
                @{ Name = "Worker"; Expression = { $_.worker } }
            ) | Sort-Object -Property "Worker"
        )
        $Data = ConvertTo-Json @($Workers | Select-Object) -Depth 4
        Break
    }
    Default { 
        # Set index page
        If ($Path -eq "/") { $Path = "/index.html" }

        # Check if there is a file with the requested path
        $Filename = "$BasePath$Path"
        If (Test-Path -LiteralPath $Filename -PathType Leaf) { 
            # If the file is a PowerShell script, execute it and return the output. A $Parameters parameter is sent built from the query string
            # Otherwise, just return the contents of the file
            $File = Get-ChildItem $Filename -File

            If ($File.Extension -eq ".ps1") { 
                $Data = & $File.FullName -Parameters $Parameters
            }
            Else { 
                $Data = Get-Content $Filename -Raw

                # Process server side includes for html files
                # Includes are in the traditional '<!-- #include file="/path/filename.html" -->' format used by many web servers
                If ($File.Extension -eq ".html") { 
                    $IncludeRegex = [regex]'<!-- *#include *file="(.*)" *-->'
                    $IncludeRegex.Matches($Data).Foreach(
                        { 
                            $IncludeFile = $BasePath + '/' + $_.Groups[1].Value
                            If (Test-Path -LiteralPath $IncludeFile -PathType Leaf) { 
                                $IncludeData = Get-Content $IncludeFile -Raw
                                $Data = $Data -replace $_.Value, $IncludeData
                            }
                        }
                    )
                }
            }

            # Set content type based on file extension
            If ($MIMETypes.ContainsKey($File.Extension)) { 
                $ContentType = $MIMETypes[$File.Extension]
            }
            Else { 
                # If it's an unrecognized file type, prompt for download
                $ContentType = "application/octet-stream"
            }
        }
        Else { 
            $StatusCode = 404
            $ContentType = "text/html"
            $Data = "URI '$Path' is not a valid resource."
        }
    }
}

# If $Data is null, the API will just return whatever data was in the previous request. Instead, show an error
# This happens if the script just started and hasn't filled all the properties in yet.
If ($null -eq $Data) { 
    $Data = @{ "Error" = "API data not available" } | ConvertTo-Json
}

# Fix for Powershell 5.1, cannot handle NaN in Json
If ($PSVersionTable.PSVersion -lt [Version]"6.0.3" ) { $Data = $Data -replace '":\s*NaN,', '":  "-",' }

$Data