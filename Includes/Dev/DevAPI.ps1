$Request = '2022-12-13 22:33:07: http://127.0.0.1:3999/functions/config/set?{"Algorithm"%3A%5B%5D%2C"APIlogfile"%3A"Debug%5C%5CAPILog.txt"%2C"APIPort"%3A3999%2C"AutoReboot"%3Atrue%2C"AutoUpdate"%3Atrue%2C"AutoUpdateCheckInterval"%3A1%2C"BackupOnAutoUpdate"%3Atrue%2C"BadShareRatioThreshold"%3A0.05%2C"BalancesKeepAlive"%3Atrue%2C"BalancesShowAverages"%3Afalse%2C"BalancesShowInAllCurrencies"%3Afalse%2C"BalancesShowInFIATcurrency"%3Atrue%2C"BalancesShowSums"%3Afalse%2C"BalancesTrackerExcludePool"%3A%5B"_BlockMasters"%5D%2C"BalancesTrackerLog"%3Afalse%2C"BalancesTrackerPollInterval"%3A10%2C"CalculatePowerCost"%3Atrue%2C"ConfigFileVersion"%3A"4.3.4.6"%2C"CPUMinerProcessPriority"%3A-2%2C"Currency"%3A"CHF"%2C"DecimalsMax"%3A6%2C"Delay"%3A0%2C"DisableDualAlgoMining"%3Afalse%2C"DisableMinerFee"%3Afalse%2C"DisableMinersWithFee"%3Afalse%2C"DisableSingleAlgoMining"%3Afalse%2C"Donation"%3A2%2C"EarningsAdjustmentFactor"%3A0.8%2C"ExcludeDeviceName"%3A%5B"CPU%2300"%5D%2C"ExcludeMinerName"%3A%5B%5D%2C"ExtraCurrencies"%3A%5B"ETH"%2C"USD"%2C"EUR"%2C"NZD"%2C"AUD"%2C"THB"%5D%2C"GPUMinerProcessPriority"%3A-1%2C"IdleDetection"%3Afalse%2C"IdleSec"%3A5%2C"IgnoreMinerFee"%3Afalse%2C"IgnorePoolFee"%3Afalse%2C"IgnorePowerCost"%3Atrue%2C"Interval"%3A30%2C"LogBalanceAPIResponse"%3Afalse%2C"LogToFile"%3A%5B"Info"%2C"Warn"%2C"Error"%2C"Verbose"%2C"Debug"%5D%2C"LogToScreen"%3A%5B"Info"%2C"Warn"%2C"Error"%2C"Verbose"%2C"Debug"%5D%2C"MinAccuracy"%3A0.5%2C"MinDataSample"%3A20%2C"MinDataSampleAlgoMultiplier"%3A{"X16r"%3A3}%2C"MinerSwitchingThreshold"%3A2.5%2C"MinerWindowStyle"%3A"minimized"%2C"MinerWindowStyleNormalWhenBenchmarking"%3Atrue%2C"MiningDutchAPIKey"%3A"7c5ea2d2e997f5094a55969d3a855c4169b46d5eee6065d4fa9251e026980714"%2C"MiningDutchUserName"%3A"UselessGuru"%2C"MiningPoolHubAPIKey"%3A"28328accdd4306c631a881bd8130f0d258a94b0e33569e0eef7e83773d018c98"%2C"MiningPoolHubUserName"%3A"UselessGuru"%2C"MinInterval"%3A3%2C"MinWorker"%3A0%2C"MonitoringServer"%3A"https%3A%2F%2FUG-Miner.com"%2C"MonitoringUser"%3A"8e92d491-a5e6-42d7-8928-5be72d743b0c"%2C"NiceHashAPIKey"%3A"0dfa9c5b-12f9-4f62-9152-41d6a517de00"%2C"NiceHashAPISecret"%3A"15a4618a-1f3a-4b96-924a-48845f435d98f4f28ac4-a51b-4de0-bf8d-584929764dd5"%2C"NiceHashOrganizationId"%3A"f48afaf4-fc54-4645-af2d-56334a48aebb"%2C"NiceHashWallet"%3A"33hZYX8iFg5zm9E3geqrNgeP6TMzszZk5R"%2C"NiceHashWalletIsInternal"%3Atrue%2C"OpenFirewallPorts"%3Atrue%2C"PayoutCurrency"%3A"BTC"%2C"PoolAPIAllowedFailureCount"%3A3%2C"PoolAPIretryInterval"%3A3%2C"PoolAPItimeout"%3A3%2C"PoolName"%3A%5B"HiveON"%2C"MiningDutchPlus"%2C"MiningPoolHubCoins"%2C"NiceHash"%2C"ProHashingPlus"%2C"ZPoolCoinsPlus"%2C"ZPoolPlus"%5D%2C"PoolsConfigFile"%3A".%5C%5CConfig%5C%5CPoolsConfig.json"%2C"PoolTimeout"%3A30%2C"PowerPricekWh"%3A{"00%3A00"%3A0.26}%2C"Powerusage"%3A{"_GPU%2302"%3A35}%2C"PowerusageIdleSystemW"%3A160%2C"ProfitabilityThreshold"%3A-12.6%2C"ProHashingAPIKey"%3A"8ea6a00dea6945172167708c9784b8deead1da2f5e543ef312bfc7ed1073fe4a"%2C"ProHashingMiningMode"%3A"PPLNS"%2C"ProHashingUserName"%3A"UselessGuru"%2C"Proxy"%3A""%2C"Region"%3A"Europe"%2C"ReportToServer"%3Atrue%2C"ShowColumnAccuracy"%3Atrue%2C"ShowAllMiners"%3Afalse%2C"ShowChangeLog"%3Atrue%2C"ShowColumnCoinName"%3Atrue%2C"ShowColumnCurrency"%3Atrue%2C"ShowColumnEarnings"%3Atrue%2C"ShowColumnEarningsBias"%3Atrue%2C"ShowColumnMinerFee"%3Atrue%2C"ShowColumnPool"%3Atrue%2C"ShowPoolBalances"%3Afalse%2C"ShowColumnPoolFee"%3Atrue%2C"ShowColumnPowerCost"%3Atrue%2C"ShowPowerusage"%3Atrue%2C"ShowColumnProfit"%3Atrue%2C"ShowColumnProfitBias"%3Atrue%2C"ShowColumnUser"%3Afalse%2C"ShowWorkerStatus"%3Atrue%2C"LogViewerConfig"%3A".%5C%5CUtils%5C%5CUG-Miner_LogReader.xml"%2C"SnakeTailExe"%3A".%5C%5CUtils%5C%5CSnakeTail.exe"%2C"SSL"%3A"Prefer"%2C"StartGUI"%3Afalse%2C"StartGUIMinimized"%3Afalse%2C"StartupMode"%3A"Running"%2C"SubtractBadShares"%3Atrue%2C"SyncWindow"%3A3%2C"Transcript"%3Afalse%2C"UIstyle"%3A"light"%2C"UnrealMinerEarningFactor"%3A1%2C"UnrealisticPoolPriceFactor"%3A2%2C"UseAnycast"%3Atrue%2C"UseColorForMinerStatus"%3Atrue%2C"UsemBTC"%3Atrue%2C"UseMinerTweaks"%3Atrue%2C"Wallets"%3A{"BTC"%3A"1GPSq8txFnyrYdXL8t6S94mYdF8cGqVQJF"%2C"ETC"%3A"0x7CF99ec9029A98AFd385f106A93977D8105Fec0f"%2C"ETH"%3A"0x92e6F22C1493289e6AD2768E1F502Fc5b414a287"}%2C"Watchdog"%3Atrue%2C"WatchdogCount"%3A3%2C"WebGUI"%3Atrue%2C"WorkerName"%3A"Blackbox"}'


Set-Location("c:\Users\Stephan\Desktop\UG-Miner\")
$ScriptBody = "using module .\Includes\Include.psm1"; $Script = [ScriptBlock]::Create($ScriptBody); . $Script

$Parameters = @{ }
$Variables = [Ordered]@{ } # as case insensitive hash table
# $Session.Miners = Get-Content .\Debug\Miners.json | ConvertFrom-Json
$Session.Pools = Get-Content .\Debug\Pools.json | ConvertFrom-Json
$Session.ConfigFile = ".\Config\config.json"
$Session.PoolsConfigFile = ".\Config\PoolsConfig.json"
$Session.Earnings = Get-Content .\Debug\Earnings.json | ConvertFrom-Json
$Session.AvailableCommandLineParameters = @("Algorithm")
$Session.WatchdogTimers = Get-Content .\Debug\WatchdogTimers.json | ConvertFrom-Json
$Session.BalancesData = Get-Content "C:\Users\Stephan\Desktop\UG-Miner\Logs\BalancesTrackerData.json" | ConvertFrom-Json

# Load stats, required for stat management
Get-Stat | Out-Null

Read-ConfigFiles -ConfigFile $Session.ConfigFile

$Request = $Request.Substring(42)
$Path = $Request -replace "\?.+"

$Request -replace ".+\?" -split "&" | ForEach-Object { 
    $Key, $Value = $_ -split "="
    # Decode any url escaped characters in the key and value
    $Key = [URI]::UnescapeDataString($Key)
    $Value = [URI]::UnescapeDataString($Value)
    if ($Key -and $Value) { $Parameters.$Key = $Value }
}

# Create a new response and the defaults for associated settings
$Response = $Context.Response
$ContentType = "application/json"
$StatusCode = 200
$Data = ""

# Set the proper content type, status code and data for each resource
switch ($Path) { 
    "/functions/algorithm/disable" { 
        # Disable algorithm@pool in poolsconfig.json
        $PoolNames = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Name
        $Algorithms = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Algorithm
        if ($Pools = @($Session.Pools.where({ $PoolNames -contains $_.Name -and $Algorithms -contains $_.Algorithm }))) { 
            $Config.Pools = [System.IO.File]::ReadAllLines($Session.PoolsConfigFile) | ConvertFrom-Json
            foreach ($Pool in $Pools) { 
                if ($PoolsConfig.($Pool.Name).Algorithm -like "-*") { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm += "-$($Pool.Algorithm)") | Sort-Object -Unique
                    $Pool.Reasons = $Pool.Reasons.Add("Algorithm disabled (`-$($Pool.Algorithm)` in $($Pool.Name) pool config)") | Out-Null
                }
                else { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm.where({ $_ -ne "+$($Pool.Algorithm)" }) | Sort-Object -Unique)
                    $Pool.Reasons = $Pool.Reasons.Add("Algorithm not enabled in $($Pool.Name) pool config") | Out-Null
                }
                $Pool.Available = $false
                $Data += "$($Pool.Algorithm)@$($Pool.Name)"
            }
            $Message = "$($Pools.Count) $(if ($Pools.Count -eq 1) { "pool" } else { "pools" }) disabled."
            Write-Message -Level Verbose "Web GUI: $Message"
            $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            $Config.Pools | Get-SortedObject | ConvertTo-Json -Depth 10 | Out-File -LiteralPath $Session.PoolsConfigFile -Force
        }
        else { 
            $Data = "No matching stats found."
        }
        Remove-Variable Algorithms, Message, Pool, PoolNames, Pools, Config.Pools -ErrorAction Ignore
        break
    }
    "/functions/algorithm/enable" { 
        # Enable algorithm@pool in poolsconfig.json
        $PoolNames = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Name
        $Algorithms = @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore).Algorithm
        if ($Pools = @($Session.Pools.where({ $PoolNames -contains $_.Name -and $Algorithms -contains $_.Algorithm }))) { 
            $Config.Pools = [System.IO.File]::ReadAllLines($Session.PoolsConfigFile) | ConvertFrom-Json
            foreach ($Pool in $Pools) { 
                if ($PoolsConfig.($Pool.Name).Algorithm -like "+*") { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm += "+$($Pool.Algorithm)" | Sort-Object -Unique)
                    $Pool.Reasons.Remove("Algorithm not enabled in $($Pool.Name) pool config") | Out-Null
                }
                else { 
                    $PoolsConfig.($Pool.Name).Algorithm = @($PoolsConfig.($Pool.Name).Algorithm.where({ $_ -ne "-$($Pool.Algorithm)" }) | Sort-Object -Unique)
                    $Pool.Reasons.Remove("Algorithm disabled (`-$($Pool.Algorithm)` in $($Pool.Name) pool config)") | Out-Null
                }
                if (-not $Pool.Reasons.Count) { 
                    $Pool.Available = $true
                    $Pool.Reasons = [System.Collections.Generic.SortedSet[String]]::new()
                }
                $Data += "$($Pool.Algorithm)@$($Pool.Name)"
            }
            $Message = "$($Pools.Count) $(if ($Pools.Count -eq 1) { "pool" } else { "pools" }) enabled."
            Write-Message -Level Verbose "Web GUI: $Message"
            $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            $Config.Pools | Get-SortedObject | ConvertTo-Json -Depth 10 | Out-File -LiteralPath $Session.PoolsConfigFile -Force
        }
        else { 
            $Data = "No matching stats found."
        }
        Remove-Variable Algorithms, Message, Pool, Pools, Config.Pools -ErrorAction Ignore
        break
    }
    "/functions/api/stop" { 
        Write-Message -Level Verbose "API: API stopped!"
        return
    }
    "/functions/balancedata/remove" { 
        if ($Parameters.Data) { 
            $BalanceDataEntries = $Session.BalancesData
            $Session.BalancesData = @((Compare-Object $Session.BalancesData @($Parameters.Data | ConvertFrom-Json -ErrorAction Ignore) -PassThru -Property DateTime, Pool, Currency, Wallet).where({ $_.SideIndicator -eq "<=" }) | Select-Object -ExcludeProperty SideIndicator)
            $Session.BalancesData | ConvertTo-Json | Out-File ".\Data\BalancesTrackerData.json"
            $RemovedEntriesCount = $BalanceDataEntries.Count - $Session.BalancesData.Count
            if ($RemovedEntriesCount -gt 0) { 
                $Message = "$RemovedEntriesCount balance data $(if ($RemovedEntriesCount -eq 1) { "entry" } else { "entries" }) removed."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = $Message
            }
            else { 
                $Data = "No matching entries found."
            }
            Remove-Variable BalanceDataEntries, Message, RemovedEntriesCount -ErrorAction Ignore
            break
        }
    }
    "/functions/config/device/disable" { 
        foreach ($Key in $Parameters.Keys) { 
            if ($Values = @(($Parameters.$Key -split ",").where({ $_ -notin $Config.ExcludeDeviceName }))) { 
                try { 
                    $ExcludeDeviceName = $Config.ExcludeDeviceName
                    $Config.ExcludeDeviceName = @((@($Config.ExcludeDeviceName) + $Values) | Sort-Object -Unique)
                    Write-Configuration -Config $Config
                    $Data = "Device configuration changed`n`nOld values:"
                    $Data += "`nExcludeDeviceName: '[$($ExcludeDeviceName -join ", ")]'"
                    $Data += "`n`nNew values:"
                    $Data += "`nExcludeDeviceName: '[$($Config."ExcludeDeviceName" -join ", ")]'"
                    $Data += "`n`nConfiguration saved to '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`nIt will become active in the next cycle."
                    $Session.Devices.where({ $Values -contains $_.Name }).ForEach(
                        { 
                            $_.State = [DeviceState]::Disabled
                            if ("Benchmarking", "Running", "WarmingUp" -contains $_.SubStatus) { $_.StatusInfo = "$($_.StatusInfo); will get disabled at end of cycle" }
                            else { 
                                $_.StatusInfo = "Disabled (ExcludeDeviceName: '$($_.Name)')"
                                $_.Status = "Idle"
                            }
                        }
                    )
                    Write-Message -Level Verbose "Web GUI: Device$(if ($Values.Count -ne 1) { "s" }) '$($Values -join ", ")' disabled. Configuration file '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))' updated."
                }
                catch { 
                    $Data = "Error saving configuration file '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`n`n[ $($_) ]"
                }
            }
            else { 
                $Data = "No configuration change."
            }
        }
        Remove-Variable ExcludeDeviceName, Key, Values -ErrorAction Ignore
        break
    }
    "/functions/config/device/enable" { 
        foreach ($Key in $Parameters.Keys) { 
            if ($Values = @(($Parameters.$Key -split ",").where({ $Config.ExcludeDeviceName -contains $_ }))) { 
                try { 
                    $ExcludeDeviceName = $Config.ExcludeDeviceName
                    $Config.ExcludeDeviceName = @($Config.ExcludeDeviceName.where({ $_ -notin $Values }) | Sort-Object -Unique)
                    Write-Configuration -Config $Config
                    $Session.ConfigurationHasChangedDuringUpdate = $false
                    $Data = "Device configuration changed`n`nOld values:"
                    $Data += "`nExcludeDeviceName: '[$($ExcludeDeviceName -join ", ")]'"
                    $Data += "`n`nNew values:"
                    $Data += "`nExcludeDeviceName: '[$($Config."ExcludeDeviceName" -join ", " )]'"
                    $Data += "`n`nConfiguration saved to '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`nIt will become active in the next cycle."
                    $Session.Devices.where({ $Values -contains $_.Name }).ForEach(
                        { 
                            $_.State = [DeviceState]::Enabled
                            if ($_.StatusInfo -like "* {*@*}; will get enabled at end of cycle") { $_.StatusInfo = $_.StatusInfo -replace "; will get enabled at end of cycle" }
                            else { $_.Status = $_.StatusInfo = $_.SubStatus = "Idle" }
                        }
                    )
                    Write-Message -Level Verbose "Web GUI: Device$(if ($Values.Count -ne 1) { "s" }) '$($Values -join ", ")' enabled. Configuration file '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))' updated."
                }
                catch { 
                    $Data = "Error saving configuration file '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`n`n[ $($_) ]"
                }
            }
            else { 
                $Data = "No configuration change."
            }
        }
        Remove-Variable ExcludedDeviceName, Key, Values -ErrorAction Ignore
        break
    }
    "/functions/config/set" { 
        try { 
            $TempConfig = ($Key | ConvertFrom-Json -AsHashtable)
            Write-Configuration -Config $TempConfig
            Write-Message -Level Verbose "Web GUI: Configuration saved to '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'. It will become fully active in the next cycle."

            $TempConfig.Keys.ForEach({ $Config.$_ = $TempConfig.$_ })

            $Session.Devices.where({ $_.State -ne [DeviceState]::Unsupported }).ForEach(
                { 
                    if ($Config.ExcludeDeviceName -contains $_.Name) { 
                        $_.State = [DeviceState]::Disabled
                        if ($_.Status -like "Mining *}") { $_.Status = "$($_.Status); will get disabled at end of cycle" }
                    }
                    else { 
                        $_.State = [DeviceState]::Enabled
                        if ($_.Status -like "*; will get disabled at end of cycle") { $_.Status = $_.Status -replace "; will get disabled at end of cycle" }
                        if ($_.Status -like "Disabled *") { $_.Status = "Idle" }
                    }
                }
            )
            $Session.Remove("ConfigurationHasChangedDuringUpdate")
            $Session.RestartCycle = $true
            $Data = "Configuration saved to '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`nIt will become fully active in the next cycle."
        }
        catch { 
            $Data = "Error saving configuration file '$($Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\"))'.`n`n[ $($_) ]"
        }
        Remove-Variable Key, TempConfig -ErrorAction Ignore
        break
    }
    "/functions/file/edit" { 
        $Data = Edit-File $Parameters.FileName
        if (Test-Path -LiteralPath $Parameters.FileName) { 
            if ($Parameters.FileName -eq $Session.ConfigFile -or $Parameters.FileName -eq $Session.PoolsConfigFile) { Read-ConfigFiles }
        }
        break
    }
    "/functions/file/showcontent" { 
        $Data = (Get-Content -Path $Parameters.FileName -Raw)
        $ContentType = "text/html"
        break
    }
    "/functions/log/get" { 
        $Lines = if ([Int]$Parameters.Lines) { [Int]$Parameters.Lines } else { 100 }
        $Data = "$((Get-Content -Path $Session.LogFile -Tail $Lines).ForEach({ "$($_)`n" }))"
        Remove-Variable Lines
        break
    }
    "/functions/mining/getstatus" { 
        if ($Session.ConfigurationHasChangedDuringUpdate) { 
            $Data = "ConfigurationHasChangedDuringUpdate" | ConvertTo-Json
        }
        else { 
            $Data = $Session.NewMiningStatus | ConvertTo-Json
        }
        break
    }
    "/functions/mining/pause" { 
        if ($Session.MiningStatus -ne "Paused") { 
            $Session.NewMiningStatus = "Paused"
            $Data = "Mining is being paused...`n$(if ($Session.BalancesTrackerPollInterval -gt 0) { If ($Session.BalancesTrackerRunning) { "Balances tracker running." } else { "Balances tracker starting..." } })"
            $Session.SuspendCycle = $false
            $Session.RestartCycle = $true
        }
        break
    }
    "/functions/mining/start" { 
        if ($Session.MiningStatus -ne "Running") { 
            $Session.NewMiningStatus = "Running"
            $Data = "Mining processes starting...`n$(if ($Session.BalancesTrackerPollInterval -gt 0) { If ($Session.BalancesTrackerRunning) { "Balances tracker running." } else { "Balances tracker starting..." } })"
            $Session.SuspendCycle = $false
            $Session.RestartCycle = $true
        }
        break
    }
    "/functions/mining/stop" { 
        if ($Session.MiningStatus -ne "Idle") { 
            $Session.NewMiningStatus = "Idle"
            $Data = "$($Session.Branding.ProductLabel) is stopping...`n"
            $Session.SuspendCycle = $false
            $Session.RestartCycle = $true
        }
        break
    }
    "/functions/querypoolapi" { 
        if (-not $Session.Config.Pools.$($Parameters.Pool).BrainConfig.$($Parameters.Type)) { 
            $Data = "No pool configuration data for '/functions/querypoolapi?Pool=$($Parameters.Pool)&Type=$($Parameters.Type)'."
        }
        elseif (-not ($Data = (Invoke-RestMethod -Uri $Session.Config.Pools.$($Parameters.Pool).BrainConfig.$($Parameters.Type) -Headers @{ "Cache-Control" = "no-cache" } -SkipCertificateCheck -TimeoutSec 5) | ConvertTo-Json)) { 
            $Data = "No data for '/functions/querypoolapi?Pool=$($Parameters.Pool)&Type=$($Parameters.Type)'."
        }
        break
    }
    "/functions/removeorphanedminerstats" { 
        if ($StatNames = Remove-ObsoleteMinerStats) { 
            $Data = $StatNames | ConvertTo-Json
        }
        else { 
            $Data = "No matching stats found."
        }
        Remove-Variable StatNames -ErrorAction Ignore
        break
    }
    # "/functions/getminerdetail" { 
    #     $Miner = $Session.Miners.where({ $_.Info -eq $Key })
    #     If ($Miner) { 
    #         $Data = $Miner | ConvertTo-Json -Depth 10
    #     }
    #     Else { 
    #         $Data = "Miner with key '$Key' not found."
    #     }
    #     Remove-Variable Miner -ErrorAction Ignore
    #     Break
    # }
    "/functions/stat/disable" { 
        if ($Parameters.Miners) { 
            if ($Miners = Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info) { 
                $Data = @()
                $Miners.ForEach(
                    { 
                        [Void](Set-MinerDisabled $_)
                        $Data += $_.Name
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Disabled $($Data.Count) miner$(if ($Data.Count -ne 1) { "s" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            }
            else { 
                $Data = "No matching miners found."
            }
            Remove-Variable Miners, Message, Worker -ErrorAction Ignore
            break
        }
    }
    "/functions/stat/enable" { 
        if ($Parameters.Miners) { 
            if ($Miners = Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info) { 
                $Data = @()
                $Miners.ForEach(
                    { 
                        [Void](Set-MinerEnabled $_)
                        $Data += $_.Name
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Enabled $($Data.Count) miner$(if ($Data.Count -ne 1) { "s" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            }
            else { 
                $Data = "No matching miners found."
            }
            Remove-Variable Message, Miners, Worker -ErrorAction Ignore
            break
        }
    }
    "/functions/stat/get" { 
        if ($TempStats = @(if ($null -ne $Parameters.Value) { (Get-Stat).where({ $_.Name -like "*_$($Parameters.Type)" -and $_.Live -eq $Parameters.Value }) } else { Get-Stat })) { 
            if ($null -ne $Parameters.Value) { 
                ($TempStats.Name | Sort-Object).ForEach({ $Data += "$($_ -replace "(_Hashrate|_PowerConsumption)$")`n" })
                if ($Parameters.Type -eq "Hashrate") { $Data += "`n$($TempStats.Count) stat file$(if ($TempStats.Count -ne 1) { "s" }) with $($Parameters.Value)H/s hashrate." }
                elseif ($Parameters.Type -eq "PowerConsumption") { $Data += "`n$($TempStats.Count) stat file$(if ($TempStats.Count -ne 1) { "s" }) with $($Parameters.Value)W power consumption." }
            }
            else { 
                $Data = $TempStats | ConvertTo-Json
            }
        }
        else { 
            $Data = "No matching stats found."
        }
        Remove-Variable TempStats -ErrorAction Ignore
        break
    }
    "/functions/stat/remove" { 
        if ($Parameters.Pools) { 
            if ($Pools = Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Pools | Select-Object) @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Algorithm, Currency, Name) { 
                $Data = @()
                ($Pools | Sort-Object -Property Name, Algorithm, Currency).ForEach(
                    { 
                        $StatName = "$($_.Name)_$($_.Algorithm)$(if ($_.Currency) { "-$($_.Currency)" })"
                        $Data += $StatName

                        Remove-Stat -Name "$($StatName)_Profit"

                        $_.Available = $true
                        $_.Disabled = $false
                        $_.Price = $_.Price_Bias = $_.StablePrice = $_.Accuracy = [Double]::NaN
                        $_.Reasons = [System.Collections.Generic.SortedSet[String]]::new()
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Reset pool stats for $($Pools.Count) $(if ($Pools.Count -eq 1) { "pool" } else { "pools" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            }
            else { 
                $Data = "No matching pool stats found."
            }
            Remove-Variable Message, Pools, StatName -ErrorAction Ignore
            break
        }
        elseif ($Parameters.Miners -and $Parameters.Type -eq "Hashrate") { 
            if ($Miners = Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info) { 
                $Data = @()
                $Miners.ForEach(
                    { 
                        $Data += $_.Name
                        $_.Activated = 0 # To allow 3 attempts

                        foreach ($Worker in $_.Workers) { 
                            Remove-Stat -Name "$($_.Name)_$($Worker.Pool.Algorithm)_Hashrate"
                        }
                        Remove-Variable Worker

                        Remove-Stat -Name "$($_.Name)_PowerConsumption"

                        $_.Refresh($Session.PowerCostBTCperW, $Config)

                        # Remove watchdog
                        $Session.WatchdogTimers = $Session.WatchdogTimers | Where-Object MinerName -NE $_.Name
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Re-benchmark triggered for $($Data.Count) miner$(if ($Data.Count -ne 1) { "s" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            }
            else { 
                $Data = "No matching hashrate stats found."
            }
            Remove-Variable Message, Miners, Worker -ErrorAction Ignore
            break
        }
        elseif ($Parameters.Miners -and $Parameters.Type -eq "PowerConsumption") { 
            if ($Miners = Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info) { 
                $Data = @()
                $Miners.ForEach(
                    { 
                        $Data += $_.Name

                        $_.Activated = 0 # To allow 3 attempts

                        Remove-Stat -Name "$($_.Name)_PowerConsumption"

                        $_.Refresh($Session.PowerCostBTCperW, $Config)

                        # Remove watchdog
                        $Session.WatchdogTimers = $Session.WatchdogTimers | Where-Object MinerName -NE $_.Name
                    }
                )
                $Data = $Data | Sort-Object -Unique
                $Message = "Re-measure power consumption triggered for $($Data.Count) miner$(if ($Data.Count -ne 1) { "s" })."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            }
            else { 
                $Data = "No matching power consumption stats found."
            }
            Remove-Variable Message, Miners -ErrorAction Ignore
            break
        }
        if ($TempStats = @(if ($null -ne $Parameters.Value) { (Get-Stat).where({ $_.Name -like "*_$($Parameters.Type)" -and $_.Live -eq $Parameters.Value }) } else { (Get-Stat).where({ $_.Name -like "*_$($Parameters.Type)" }) })) { 
            $Data = @()
            ($TempStats | Sort-Object -Property Name).ForEach(
                { 
                    Remove-Stat -Name $_.Name
                    $Data += $_.Name -replace "(_Hashrate|_PowerConsumption)$"
                }
            )
            $Data = $Data | Sort-Object -Unique
            if ($Parameters.Type -eq "Hashrate") { $Message = "Reset $($TempStats.Count) stat file$(if ($TempStats.Count -ne 1) { "s" })$(if ($null -ne $Parameters.Value) { " with $($Parameters.Value)H/s hashrate" })." }
            elseif ($Parameters.Type -eq "PowerConsumption") { $Message = "Reset $($TempStats.Count) stat file$(if ($TempStats.Count -ne 1) { "s" })$(if ($null -ne $Parameters.Value) { " with $($Parameters.Value)W power consumption" })." }
            elseif ($Parameters.Type -eq "Profit") { $Message = "Reset $($TempStats.Count) pool stat file$(if ($TempStats.Count -ne 1) { "s" })." }
            Write-Message -Level Info "Web GUI: $Message"
            $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
        }
        else { 
            $Data = "No matching stats found."
        }
        Remove-Variable Message, TempStats -ErrorAction Ignore
        break
    }
    "/functions/stat/set" { 
        if ($Parameters.Miners) { 
            $Data = @()
            if ($Parameters.Type -eq "Hashrate" -and $Parameters.Value -eq 0) { 
                if ($Miners = Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Info) { 
                    $Miners.ForEach(
                        { 
                            [Void](Set-MinerFailed $_)
                            $Data += $_.Name
                        }
                    )
                    $Data = $Data | Sort-Object -Unique
                    $Message = "Marked $($Data.Count) miner$(if ($Data.Count -ne 1) { "s" }) as failed."
                    Write-Message -Level Verbose "Web GUI: $Message"
                    $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message" 
                }
                else { 
                    $Data = "No matching miners found."
                }
                Remove-Variable Algorithm, Message, Miners, StatName -ErrorAction Ignore
                break
            }
        }
    }
    "/functions/switchinglog/clear" { 
        Get-ChildItem -Path ".\Logs\SwitchingLog.csv" -File | Remove-Item -Force
        Write-Message -Level Verbose "Web GUI: Switching log '.\Logs\SwitchingLog.csv' cleared."
        $Data = "Switching log '.\Logs\SwitchingLog.csv' cleared."
        break
    }
    "/functions/variables/get" { 
        if ($Key) { 
            $Data = $Session.($Key -replace "\\|/", "." -split "\."[-1]) | Get-SortedObject | ConvertTo-Json -Depth 10
        }
        else { 
            $Data = $Session.psBase.Keys | Sort-Object | ConvertTo-Json -Depth 1
        }
        break
    }
    "/functions/watchdogtimers/remove" { 
        if ($Parameters.Miners -or $Parameters.Pools) { 
            $Data = @()
            foreach ($Miner in (Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Miners | Select-Object) @($Parameters.Miners | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Name)) { 
                if ($Session.WatchdogTimers.where({ $_.MinerName -eq $Miner.Name })) { 
                    # Update miner
                    $Data += $Miner.Name
                    $Miner.Reasons.where({ $_ -like "Miner suspended by watchdog *" }).ForEach({ $Miner.Reasons.Remove($_) | Out-Null })
                    if (-not $Miner.Reasons.Count) { $Miner.Available = $true }

                    # Remove Watchdog timers
                    $Session.WatchdogTimers = $Session.WatchdogTimers.where({ $_.MinerName -ne $Miner.Name })
                }
            }
            Remove-Variable Miner

            foreach ($Pool in (Compare-Object -PassThru -IncludeEqual -ExcludeDifferent @($Session.Pools | Select-Object) @($Parameters.Pools | ConvertFrom-Json -ErrorAction Ignore | Select-Object) -Property Key)) { 
                # Update pool
                if ($Session.Pools.where({ $_.Key -eq $Pool.Key })) { 
                    $Data += "$($Pool.Key) [$($Pool.Region)]"
                    $Pool.Reasons.where({ $_ -like "Miner suspended by watchdog *" }).ForEach({ $Pool.Reasons.Remove($_) | Out-Null })
                    if (-not $Pool.Reasons.Count) { $Pool.Available = $true }

                    # Remove Watchdog timers
                    $Session.WatchdogTimers = $Session.WatchdogTimers.where({ $_.Key -ne $Pool.Key })
                }
            }
            Remove-Variable Pool

            if ($Data = $Data | Sort-Object -Unique) { 
                $Message = "$($Data.Count) watchdog $(if ($Data.Count -eq 1) { "timer" } else { "timers" }) removed."
                Write-Message -Level Verbose "Web GUI: $Message"
                $Data = "$(($Data | Sort-Object) -join "`n")`n`n$Message"
            }
            else { 
                $Data = "No matching watchdog timer found."
            }
            Remove-Variable Message, Miner, Pool -ErrorAction Ignore
        }
        else { 
            $Session.WatchdogTimers = [System.Collections.Generic.List[PSCustomObject]]::new()
            foreach ($Miner in $Session.Miners) { 
                $Miner.Reasons.where({ $_ -like "Miner suspended by watchdog *" }).ForEach({ $Miner.Reasons.Remove($_) | Out-Null })
                if (-not $Miner.Reasons.Count) { $_.Available = $true }
            }
            Remove-Variable Miner

            foreach ($Pool in $Session.Pools.ForEach) { 
                $Pool.Reasons.where({ $_ -like "Pool suspended by watchdog *" }).ForEach({ $Pool.Reasons.Remove($_) | Out-Null })
                if (-not $Pool.Reasons.Count) { $Pool.Available = $true }
            }
            Remove-Variable Pool

            Write-Message -Level Verbose "Web GUI: All watchdog timers removed."
            $Data = "All watchdog timers removed.`nWatchdog timers will be recreated in the next cycle."
        }
        break
    }
    "/algorithms" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Algorithms | Select-Object)
        break
    }
    "/algorithms/lastused" { 
        $Data = ConvertTo-Json -Depth 10 $Session.AlgorithmsLastUsed
        break
    }
    "/allcurrencies" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.AllCurrencies)
        break
    }
    "/apiversion" { 
        $Data = $Session.APIversion
        break
    }
    "/balances" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.Balances | Sort-Object -Property DateTime -Bottom 10000 | Select-Object)
        break
    }
    "/balancedata" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.BalancesData | Sort-Object -Property DateTime -Descending)
        break
    }
    "/btc" { 
        $Data = $Session.Rates.BTC.($Config.FIATcurrency)
        break
    }
    "/balancescurrencies" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.BalancesCurrencies)
        break
    }
    "/braindata" { 
        $Data = ConvertTo-Json -Depth 2 ($Session.BrainData | Get-SortedObject)
        break
    }
    "/coinnames" { 
        $Data = [System.IO.File]::ReadAllLines(".\Data\CoinNames.json")
        break
    }
    "/config" { 
        $Data = ConvertTo-Json -Depth 10 ([System.IO.File]::ReadAllLines($Session.ConfigFile) | ConvertFrom-Json -Depth 10 | Get-SortedObject)
        if (-not ($Data | ConvertFrom-Json).ConfigFileVersion) { 
            $Data = ConvertTo-Json -Depth 10 ($Config | Select-Object -ExcludeProperty PoolsConfig)
        }
        break
    }
    "/configfile" { 
        $Data = $Session.ConfigFile.Replace("$(Convert-Path ".\")\", ".\")
        break
    }
    "/configrunning" { 
        $Data = ConvertTo-Json -Depth 10 $Session.Config
        break
    }
    "/cpufeatures" { 
        $Data = ConvertTo-Json $Session.CPUfeatures
        break
    }
    "/currency" { 
        $Data = $Config.FIATcurrency
        break
    }
    "/currencyalgorithm" { 
        $Data = [System.IO.File]::ReadAllLines("$PWD\Data\CurrencyAlgorithm.json")
        break
    }
    "/dagdata" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.DAGdata | Get-SortedObject)
        break
    }
    "/devices" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Devices | Sort-Object -Property Name)
        break
    }
    "/devices/enabled" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Devices.where({ $_.State -eq "Enabled" }) | Sort-Object -Property Name)
        break
    }
    "/devices/disabled" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Devices.where({ $_.State -eq "Disabled" }) | Sort-Object -Property Name)
        break
    }
    "/devices/unsupported" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Devices.where({ $_.State -eq "Unsupported" }) | Sort-Object -Property Name)
        break
    }
    "/donationdata" { 
        $Data = ConvertTo-Json $Session.DonationData
        break
    }
    "/donationlog" { 
        $Data = ConvertTo-Json -Depth 10 @([System.IO.File]::ReadAllLines("$PWD\Logs\DonationLog.csv") | ConvertFrom-Csv -ErrorAction Ignore)
        break
    }
    "/driverversion" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.DriverVersion | Select-Object)
        break
    }
    "/earningschartdata" { 
        $Data = ConvertTo-Json $Session.EarningsChartData
        break
    }
    "/equihashcoinpers" { 
        $Data = [System.IO.File]::ReadAllLines("$PWD\Data\EquihashCoinPers.json")
        break
    }
    "/extracurrencies" { 
        $Data = ConvertTo-Json -Depth 10 $Config.ExtraCurrencies
        break
    }
    "/fiatcurrencies" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.FIATcurrencies | Select-Object)
        break
    }
    "/miners" { 
        $Data = ConvertTo-Json -Depth 5 -Compress @(($Session.Miners | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).PsObject.Copy().ForEach({ if ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/available" { 
        $Bias = if ($Session.CalculatePowerCost -and -not $Config.IgnorePowerCost) { "Profit_Bias" } else { "Earnings_Bias" }
        $Data = ConvertTo-Json -Depth 5 @($Session.Miners.where({ $_.Available }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object DeviceNames, @{ Expression = $Bias; Descending = $true })
        Remove-Variable Bias
        break
    }
    "/miners/bestperdevice" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.MinersBestPerDevice | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).PsObject.Copy().ForEach({ if ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning | Sort-Object -Property DeviceName)
        break
    }
    "/miners/best" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.MinersBest | Sort-Object { $_.BaseName_Version_Device -replace ".+-" }, Info | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).PsObject.Copy().ForEach({ if ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/disabled" { 
        $Data = ConvertTo-Json -Depth 5 @($Session.Miners.where({ $_.Status -eq [MinerStatus]::Disabled }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object -Property { $_.DeviceNames }, EndTime)
        break
    }
    "/miners/failed" { 
        $Data = ConvertTo-Json -Depth 5 @($Session.Miners.where({ $_.Status -eq [MinerStatus]::Failed }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object -Property { $_.DeviceNames }, EndTime)
        break
    }
    "/miners/launched" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.MinersBest | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).PsObject.Copy().ForEach({ if ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/missingbinary" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.MinersMissingBinary | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/missingfirewallrule" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.MinersMissingFirewallRule | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/missingprerequisite" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.MinersMissingPrerequisite | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/optimal" { 
        $Data = ConvertTo-Json -Depth 5 @($Session.MinersOptimal | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp)
        break
    }
    "/miners/running" { 
        $Data = ConvertTo-Json -Depth 5 @(($Session.Miners.where({ $_.Status -eq [MinerStatus]::Running }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp).PsObject.Copy().ForEach({ if ($_.WorkersRunning) { $_.Workers = $_.WorkersRunning }; $_ }) | Select-Object -ExcludeProperty WorkersRunning)
        break
    }
    "/miners/unavailable" { 
        $Data = ConvertTo-Json -Depth 5 @($Session.Miners.where({ $_.Available -ne $true }) | Select-Object -ExcludeProperty Arguments, Data, DataReaderJob, DataSampleTimestamp, Devices, EnvVars, PoolNames, Process, ProcessJob, SideIndicator, StatEnd, StatStart, ValidDataSampleTimestamp | Sort-Object -Property { $_.DeviceNames }, Name, Algorithm)
        break
    }
    "/miningpowercost" { 
        $Data = $Session.MiningPowerCost
        break
    }
    "/miningearnings" { 
        $Data = $Session.MiningEarnings
        break
    }
    "/miningprofit" { 
        $Data = $Session.MiningProfit
        break
    }
    "/poolname" { 
        $Data = ConvertTo-Json -Depth 10 $Config.PoolName
        break
    }
    "/pooldata" { 
        $Data = ConvertTo-Json -Depth 10 $Session.PoolData
        break
    }
    "/poolsconfig" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.Config.Pools | Select-Object)
        break
    }
    "/poolsconfigfile" { 
        $Data = $Session.PoolsConfigFile.Replace("$(Convert-Path ".\")\", ".\")
        break
    }
    "/pools" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Pools | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/added" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.PoolsAdded | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/available" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Pools.where({ $_.Available }) | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/best" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.PoolsBest | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/expired" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.PoolsExpired | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/new" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.PoolsNew | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/minersprimaryalgorithm" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.MinerPools[0] | Select-Object)
        break
    }
    "/pools/minerssecondaryalgorithm" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.MinerPools[1] | Select-Object)
        break
    }
    "/pools/lastearnings" { 
        $Data = ConvertTo-Json -Depth 10 $Session.PoolsLastEarnings
        break
    }
    "/pools/lastused" { 
        $Data = ConvertTo-Json -Depth 10 $Session.PoolsLastUsed
        break
    }
    "/pools/unavailable" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Pools.where({ -not $_.Available }) | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/pools/updated" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.PoolsUpdated | Sort-Object -Property Algorithm, Name, Region)
        break
    }
    "/poolreasons" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.Pools.where({ -not $_.Available }).Reasons | Sort-Object -Unique)
        break
    }
    "/poolvariants" { 
        $Data = ConvertTo-Json -Depth 10 $Session.PoolVariants
        break
    }
    "/rates" { 
        $Data = ConvertTo-Json -Depth 10 ($Session.Rates | Select-Object)
        break
    }
    "/refreshtimestamp" { 
        $Data = $Session.RefreshTimestamp | ConvertTo-Json
        break
    }
    "/regions" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Regions[0] | Sort-Object)
        break
    }
    "/regionsdata" { 
        $Data = ConvertTo-Json -Depth 10 $Session.Regions
        break
    }
    "/stats" { 
        $Data = ConvertTo-Json -Depth 10 ($Stats | Select-Object)
        break
    }
    "/summarytext" { 
        $Data = ConvertTo-Json -Depth 10 @((($Session.Summary -replace " / ", "/" -replace "&ensp;", " " -replace "   ", "  ") -split "<br>").trim())
        break
    }
    "/summary" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.Summary | Select-Object)
        break
    }
    "/switchinglog" { 
        $Data = ConvertTo-Json -Depth 10 @([System.IO.File]::ReadAllLines("$PWD\Logs\SwitchingLog.csv") | ConvertFrom-Csv | Select-Object -Last 1000 | Sort-Object -Property DateTime -Descending)
        break
    }
    "/unprofitablealgorithms" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.UnprofitableAlgorithms | Select-Object)
        break
    }
    "/version" { 
        $Data = ConvertTo-Json @("$($Session.Branding.ProductLabel) Version: $($Session.Branding.Version)", "API Version: $($Session.APIversion)", "PWSH Version: $($PSVersionTable.PSVersion.ToString())")
        break
    }
    "/watchdogtimers" { 
        $Data = ConvertTo-Json -Depth 10 @($Session.WatchdogTimers | Select-Object)
        break
    }
    "/wallets" { 
        $Data = ConvertTo-Json -Depth 10 ($Config.Wallets | Select-Object)
        break
    }
    "/watchdogexpiration" { 
        $Data = $Session.WatchdogReset
        break
    }
    "/workers" { 
        if ($Config.ShowWorkerStatus -and $Config.MonitoringUser -and $Config.MonitoringServer -and $Session.WorkersLastUpdated -lt [DateTime]::Now.AddSeconds(-30)) { 
            [Void](Read-MonitoringData)
        }
        if ($Session.Workers) { 
            $Workers = [System.Collections.ArrayList]@(
                $Session.Workers | Select-Object @(
                    @{ Name = "Algorithm"; Expression = { $_.data.ForEach({ $_.Algorithm -split "," -join " & " }) -join "<br>" } },
                    @{ Name = "Benchmark Hashrate"; Expression = { $_.data.ForEach({ ($_.EstimatedSpeed.ForEach({ if ([Double]$_ -gt 0) { "$($_ | ConvertTo-Hash)/s" -replace " \s+" } else { "-" } })) -join " & " }) -join "<br>" } },
                    @{ Name = "Currency"; Expression = { $_.Data.Currency | Select-Object -Unique } },
                    @{ Name = "EstimatedEarnings"; Expression = { [Decimal]((($_.Data.Earnings | Measure-Object -Sum).Sum) * $Session.Rates.BTC.($_.Data.Currency | Select-Object -Unique)) } },
                    @{ Name = "EstimatedProfit"; Expression = { [Decimal]($_.Profit * $Session.Rates.BTC.($_.Data.Currency | Select-Object -Unique)) } },
                    @{ Name = "LastSeen"; Expression = { $_.date } },
                    @{ Name = "Live Hashrate"; Expression = { $_.data.ForEach({ ($_.CurrentSpeed.ForEach({ if ([Double]$_ -gt 0) { "$($_ | ConvertTo-Hash)/s" -replace " \s+" } else { "-" } })) -join " & " }) -join "<br>" } },
                    @{ Name = "Miner"; Expression = { $_.data.name -join "<br/>" } },
                    @{ Name = "Pool"; Expression = { $_.data.ForEach({ $_.Pool -split "," -join " & " }) -join "<br>" } },
                    @{ Name = "Status"; Expression = { $_.status } },
                    @{ Name = "Version"; Expression = { $_.version } },
                    @{ Name = "Worker"; Expression = { $_.worker } }
                ) | Sort-Object -Property "Worker"
            )
            $Data = ConvertTo-Json @($Workers | Select-Object) -Depth 4
        }
        else { 
            $Data = "No worker data from reporting server"
        }
        break
    }
    default { 
        # Set index page
        if ($Path -eq "/") { $Path = "/index.html" }

        # Check if there is a file with the requested path
        $Filename = "$BasePath$Path"
        if (Test-Path -LiteralPath $Filename -PathType Leaf) { 
            # If the file is a PowerShell script, execute it and return the output. A $Parameters parameter is sent built from the query string
            # Otherwise, just return the contents of the file
            $File = Get-ChildItem $Filename -File

            if ($File.Extension -eq ".ps1") { 
                $Data = & $File.FullName -Parameters $Parameters
            }
            else { 
                $Data = Get-Content $Filename -Raw

                # Process server side includes for html files
                # Includes are in the traditional '<!-- #include file="/path/filename.html" -->' format used by many web servers
                if ($File.Extension -eq ".html") { 
                    $IncludeRegex = [regex]'<!-- *#include *file="(.*)" *-->'
                    $IncludeRegex.Matches($Data).ForEach(
                        { 
                            $IncludeFile = $BasePath + "/" + $_.Groups[1].Value
                            if (Test-Path -LiteralPath $IncludeFile -PathType Leaf) { 
                                $IncludeData = Get-Content $IncludeFile -Raw
                                $Data = $Data -replace $_.Value, $IncludeData
                            }
                        }
                    )
                }
            }

            # Set content type based on file extension
            if ($MIMEtypes.ContainsKey($File.Extension)) { 
                $ContentType = $MIMEtypes[$File.Extension]
            }
            else { 
                # If it's an unrecognized file type, prompt for download
                $ContentType = "application/octet-stream"
            }
        }
        else { 
            $StatusCode = 404
            $ContentType = "text/html"
            $Data = "URI '$Path' is not a valid resource."
        }
        Remove-Variable File, Filename, IncludeData, IncludeFile, IncludeRegex, Key -ErrorAction Ignore
    }
}

# If $Data is null, the API will just return whatever data was in the previous request. Instead, show an error
# This happens if the script just started and hasn't filled all the properties in yet.
if ($null -eq $Data) { 
    $Data = @{ "Error" = "API data not available" } | ConvertTo-Json
}

$Data